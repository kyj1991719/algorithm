## 최적화문제 답 계산하기
1. 재귀 호출의 각 단계에서 최적해를 만들었던 선택을 별도의 배열에 저장함
2. 별도의 재귀 함수를 이용해 이 선택을 따라가며 각 선택지를 저장하거나 출력함

## k번째 답 계산하기
1. 답들을 사전순서대로 만들며 경우의 수를 세는 완전 탐색 알고리즘을 설계하고, 메모이제이션을 적용해 경우의 수를 세는 동적 계획법 알고리즘으로 바꿈
2. 모든 답들을 사전순으로 생성하며 skip개를 건너뛰고 첫 번째 답을 반환하는 재귀 호출 함수를 구현함. 이 값을 선택했을때 만들어지는 답의수 M과 건너뛰어야할 답의 수 skip을 비교함
<br>
2.1. M <= skip : M개의 답은 원하는 답보다 앞에 있으므로 건너뛰고 skip을 M만큼 줄임
2.2. M > skip : M개의 답중에 원하는 답이 있으므로 skip개를 건너뛴 것이 답임

## 반복적 동적 계획법과 재귀적 동적 계획법 비교
#### 재귀적 동적 계획법의 장단점
1. 장점 : 좀더 직관적인 코드를 짤 수 있음
2. 장점 : 부분 문제 간의 의존 관계나 계산 순서에 대해 고민할 필요가 없음
3. 장점 : 전체 부분 문제 중 일부의 답만 필요할 경우 더 빠르게 동작함
4. 단점 : 슬라이딩 윈도 기법(필요한 부분의 일부만 메모이제이션)을 쓸 수 없음
5. 단점 : 스택 오버플로를 조심해야함

#### 반복적 동적 계획법의 장단점
1. 장점 : 구현이 대개 더 짧음
2. 장점 : 재귀 호출에 필요한 부하가 없기 때문에 조금 더 빠르게 동작함
3. 장점 : 슬라이딩 윈도 기법을 쓸 수 있음
4. 단점 : 구현이 좀 더 비직관적임
5. 단점 : 부분 문제 간의 의존 관계를 고려해 계산되는 순서르르 고민해야함

## 결정 문제
최적화 문제를 결정문제로 바꾼 뒤, 이것을 이분법을 이용해 해결하는 방법이 있음

최적화 문제의 반환값은 대개 실수나 정수이고, 결정 문제는 두가지 답만 있음

결정 문제가 최적화 문제보다 어려울 수는 없음

#### 최적화 문제 결정 문제로 바꾸기
1. "가장 좋은 답은 무엇인가?"라는 최적화 문제를 "x 혹은 그보다 좋은 답이 있는가?"라는 결정 문제 형태로 바꿈
2. 결정 문제를 쉽게 풀 수 있는 방법이 있는지 찾아봄
3. 결정 문제를 내부적으로 이용하는 이분법 알고리즘을 작성함
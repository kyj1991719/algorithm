#### 기본 용어
문자열 S = "avada" <br>
문자열 길이 |S|=5 <br>
해당 글자 S[i] => S[4] = a <br>
부분 문자열 S[i...j] => S[1...4] = vada <br>
문자열의 접두사 S[...i] => S[...3] = avad <br>
문자열의 접미사 S[i...] => S[3...] = da

#### 문자열 검색
문자열 H에서 N을 찾는 경우
1. 검색할 단어 N에 대해 접미사와 접두사가 일치하는 길이 배열 검색
2. 해당 글자가 일치하는 경우 : 답의 다음 위치부터 검색
	<br>
   불일치하는 경우 : 현재 위치에서 일치하는 글자수만큼 뺀 위치에서 다시 시작
   <br>
   완전 불일치 : 다음 글자 검색

```java
//H에서 N이 시작하는 모든 위치 반환
private static List&lt;Integer&gt; kmpSearch(String H, String N) {
	int n = H.length();
	int m = N.length();
	List&lt;Integer&gt; ret = new ArrayList&lt;&gt;();
	//N[..i]의 접두사와 접미사가 같은 문자열의 최대 길이
	int[] pi = getPartialMatch(N);
	int begin = 0, matched = 0;
	//H를 N이 들어갈 수 있는 범위까지 검색
	while(begin <= n-m) {
		//H의 해당 글자와 N의 글자가 같은 경우
		if(matched < m && H.charAt(begin+matched) == N.charAt(matched)) {
			matched++;
			//모든 글자를 찾은 경우 답에 추가
			if(matched == m) {
				ret.add(begin);
			}
		} else {
			//아무 글자도 맞지 않는 경우 다음 글자부터 검색 시작
			if(matched == 0) {
				begin++;
			} else {
				//현재까지 검색한 위치에서 일치한 글자수 만큼을 뺀 위치부터 다시 시작
				begin += matched-pi[matched-1];
				//해당 글자 길이 만큼은 항상 일치함
				matched = pi[matched-1];
			}
		}
	}
	return ret;
}

//해당 문자열의 접두사와 접미사가 같은 문자열의 최대 길이 배열

private static int[] getPartialMatch(String N) {
	int m = N.length();
	//시작값이 0일경우 자기 자신을 찾음
	int begin = 1, matched = 0;
	int[] ret = new int[m];
	while(begin+matched < m) {
		//문자열이 일치하는 경우
		if(N.charAt(begin+matched) == N.charAt(matched)) {
			matched++;
			//N[...begin+match-1]에서 접두사와 접미사가 일치하는 길이
			ret[begin+matched-1] = matched;
		} else {
			//아무것도 일치하지 않는 경우 다음 글자부터 검색 시작
			if(matched == 0) {
				begin++;
			} else {
				//현재 위치까지 일치한 위치에서 일치한 글자수만큼 뺀 위치에서 검색 시작
				begin += matched - ret[matched-1];
				//해당 글자 길이만큼은 항상 일치함
				matched = ret[matched-1];
			}
		}
	}
	return ret;
}
```

#### 접미사 배열
맨버-마이어스의 알고리즘으로 구현함
<br>
문자열의 접미사들을 1,2,4,..2*n의 배수의 문자들을 비교하면서 정렬함
<br>
문자열 : mississipi

머리1 | 머리2 | 머리3 | 뚝배기
---- | ---- | ---- | ----
다리 | 다리1 | 다리2 | 뚝배기깹니다
금 | 의 | 환 | 향
#### 너비 우선 탐색
시작점에서 가까운 정점부터 순서대로 방문함<br>
각 정점은 세 개의 상태를 순서대로 거침
1. 아직 발견되지 않은 상태
2. 발견되었지만 아직 방문하지 않은상태(큐에 저장되어 있는 상태)
3. 방문된 상태

```java
//그래프의 인접 리스트
ArrayList<Integer>[] adj;
//start에 시작해서 너비 우선 탐색 후 정점의 방문 순서 반환
int[] bfs(int start) {
	//각 정점의 방문 여부
	boolean[] discovered = new boolean[adj.size()];
	//방문할 정점 목록
	Queue<Integer> q = new LinkedList<>();
	//정점의 방문 순서
	ArrayList<Integer> order = new ArrayList<>();
	discovered[start] = true;
	q.push(start);
	while(!q.isEmpty()) {
		int here = q.poll();
		//here 방문
		order.add(here);
		//모든 인접한 정점 검사
		for(int i = 0; i < adj[here].size(); i++) {
			int there = adj[here].get(i);
			//처음보는 정점이면 방문 목록에 집어넣음
			if(!discovered[there]) {
				q.push(there);
				discovered[there] = true;
			}
		}
	}
	return order;
}
```

너비 우선탐색의 경우 대개 최단경로 문제를 풀 때 사용됨

```java
//그래프의 인접 리스트
ArrayList<Integer>[] adj;
//start에서 시작하는 너비 우선 탐색으로 각 정점까지의 최단 거리와 너비 우선 탐색 스패닝 트리를 계산함
void bfs2(int start, int[] distance, int[] parent) {
	//start부터 i까지 최단거리
	distance = new int[adj.size()];
	//너비 우선 탐색 스패닝 트리에서 i의 부모의 번호
	parent = new int[adj.size()];
	Arrays.fill(distance, -1);
	Arrays.fill(parent, -1);
	//방문 목록
	Queue<Integer> q = new LinkedList<>();
	distance[start] = 0;
	parent[start] = start;
	q.push(start);
	while(!q.isEmpty()) {
		int here = q.pop();
		//모든 인접한 정점 검사
		for(int i = 0; i < adj[here].size(); i++) {
			int there = adj[here].get(i);
			//처음 보는 정점이면 방문 목록에 집어넣음
			if(distance[there] == -1) {
				q.push(there);
				distance[there] = distance[here]+1;
				parent[there] = here;
			}
		}
	}
}
//v부터 시작점까지의 최단경로 계산
ArrayList<Integer> shortestPath(int v, int[] parent) {
	ArrayList<Integer> path = new ArrayList<>();
	while(parent[v] != v) {
		v = parent[v];
		path.add(v);
	}
	Collections.reverse(path);
	return path;
}
```
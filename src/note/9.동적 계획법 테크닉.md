### 최적화 문제의 실제 답 계산하기
최적화 문제에서 어떤 답을 선택했을때 최적해를 얻었는지 기록하고, 별도의 재귀함수를 통해 최적해의 실제답을 계산함

### 최적화 문제 답 계산하기 레시피
1. 재귀호출의 각 단계에서 최적해를 만들었던 선택을 별도의 배열에 저장함
2. 별도의 재귀함수를 이용해 이 선택을 따라가며 각 선택지를 저장하거나 출력함

```java
//최대 증가 부분 수열을 구하기
int n;  //전체 길이
        int[] S = new int[100]; //수열
        int[] cache = new int[101]; //최적화 문제의 메모이제이션
        int[] select = new int[101];//최적화 문제에서 선택한 값

//증가 부분 수열 중 최대 길이를 반환함
        int lis4(int start) {
        if(cache[start+1] != -1) {
        return cache[start+1]
        }

        int ret = 1
        int bestNext = -1;
        for(int i = start+1; i<n; i++) {
        if(start == -1 || S[start] < S[i]) {
        int cand = lis4(i)+1;
        if(cand > ret) {
        ret = cand;
        bestNext = i;
        }
        }
        }
        select[start+1] = bestNext;
        cache[start+1] = ret;
        return ret;
        }

//S[start]에서 시작하는 LIS의 값을 저장함
        void reconstruct(int start, List<Integer> list) {
        if(start != -1) {
        list.add(S[start])
        }
        int next = select[start+1];
        if(next != -1) {
        reconstruct(next, list);
        }
        }
```

### k번째 답 계산하기
1. 답들을 사전순서대로 만들며 경우의 수를 세는 완전 탐색 알고리즘을 설계하고, 메모이제이션을 적용해 경우의 수를 세는 동적 계획법 알고리즘으로 바꿈
2. 모든 답들을 사전순으로 생성하며 skip개를 건너뛰고 첫 번째 답을 반환하는 재귀 호출 함수를 구현함. 이 값을 선택했을때 만들어지는 답의수 M과 건너뛰어야할 답의 수 skip을 비교함
1. M <= skip : M개의 답은 원하는 답보다 앞에 있으므로 건너뛰고 skip을 M만큼 줄임
2. M > skip : M개의 답중에 원하는 답이 있으므로 skip개를 건너뛴 것이 답임

### 정수 이외의 입력에 대한 메모이제이션
- 연관배열 사용하기
    - map과 같은 연관 배열을 사용하여 키로 사용하여 저장함
    - key값을 비교하는데 시간이 오래걸리므로 아주 작은 문제에만 사용할 수 있음
- 일대일 대응 함수 만들기
    - 입력을 적절하게 정수로 변환해 줄 수 있는 함수를 작성함
    - 두개의 다른 입력에 대해서 같은 값을 반환하면 잘못된 답을 반환할 수 있음
    - 어떤 위치에 대응되는 입력이 없으면 해당 메모리의 크기 만큼 메모리가 낭비됨

### 여러 입력해 대한 일대일 함수 구현법
1. 불린배열인 경우

해당 위치의 값이 true인 경우 1, false인 경우 0으로 변환하여 이진수로 간주함

배열 | 이진수 표현 | 대응되는 십진수
---| ---| ---|
{true} | 1 | 1
{true,false,true,false} | 0101 | 5
{false, false, false, false} | 0000 | 0

메모리 양이 2^n에 비례하므로 n이 20을 넘어가면 해당 방법을 사용할 수 없음


2. 순열인 경우

X가 항상 [1,2,...10]의 순열이라고 하면, n!개의 입력중 X가 사전순으로 몇번쨰 오는지 계산하면됨

예) X가 [4,5,1,2,3,...]인 경우

- X의 첫 숫자가 4이므로 X앞에는 3*9!개의 배열이 있음. X는 첫숫자가 4인 입력중에 있음
- X의 두번째 숫자가 5이므로, X앞에는 3*9!+3*8!개의 배열이 있음. X는 첫숫자가 4, 두번째숫자가 5인 입력중에 있음

해당 절차는 다음과 같이 구현됨
```java
int factorials[12]; //i!
//X가 [0..n-1]의 순열일 때 사전순 번호를 반환함
        int getIndex(int[] X) {
        int ret = 0;
        for(int i = 0; i < X.length; i++) {
        int less = 0;
        //X[i+1]이후의 수중 X[i]보다 작은수를 셈. 이것이 X앞에 오는 묶음의 수가 됨
        for(int j = i+1; j < X.length; j++) {
        if(X[j] < X[i]) {
        less++;
        }
        }
        ret += factorials[X.length - i -1] * less;
        }
        return ret;
        }
```

3. 입력의 범위가 좁은경우

십진수로 표현할 수 있는 경우 배열에서 해당 위치의 수를 n자리의 수로 보면됨

원소의 범위가 [0,k-1]인 경우 n자리의 k진수로 보고 계산하면 됨


### 반복적 동적 계획법과 재귀적 동적 계획법 비교
해당 책에서는 재귀함수가 아닌 반복문을 사용하여 구현한 동적 계획법을 반복적 동적 계획법이라함

#### 사용처
1. 슬라이딩 윈도우를 이용한 공간 복잡도 줄이지
- 사용하는 데이터 전체를 메모리에 유지하는 것이 아닌 필요한 부분만을 저장하는 기법
- 새 값을 계산할 때 과거에 계산한 결과의 일부분만 필요할 때 사용할 수 있ㅇ므
```java
// 삼각형 위의 최대 경로 알고리즘
int[][] C2 = new int[2][10000];
int iterative2() {
    //맨 마지막줄을 계산함
    for(int x = 0; x < n; x++) {
        C2[(n-1)%2][x] = triangle[n-1][x];
    }
    //아래서부터 올라오면서 나머지를 계산함
    for(int y = n-2; y >= 0; y--) {
        for(int x = 0; x < y+1; x++) {
            C2[y%2][x] = Math.max(C2[(y+1)%2][x],
                            C2[(y+1)%2][x+1] + traingle[y][x]);
        }
    }
    return C2[0][0];
}
```

2. 행렬 거듭제곱을 이용한 동적 계획법

선형 변환 형태의 점화식을 행렬을 이용해 바르게 푸는 기법이 있음

예) 피보나치 수열의 n번째 숫자의 마지막 다섯자리 계산
```java
//슬라이딩 윈도를 사용
int fib(int n) {
    if(n <= 1) {
        return n;
    }
    int[] seq = new int[3];
    seq[0] = 0;
    seq[1] = 1;
    for(int i  = 2; i <= n; i++) {
        seq[i%3] = (seq[(i-1)%3] + seq[(i-2)%3]) % 100000;
    }
    return seq[n%3];
}
```

피보나치 수열을 다음과 같이 쓸 수 있음
```java
C_i = [fib(i-1)]
      [fib(i)  ]
라고 할 때 C_(i+1)은 다음과 같이 쓸 수 있음
C_(i+1) = [fib(i)  ]  = [fib(i)         ] = [C_(i,1)        ] = [0 1]C_i
          [fib(i+1)]    [fib(i-1)+fib(i)]   [C_(i,0)+C_(i,1)]   [1 1]

따라서 C_n은 다음과 같이 쓸 수 있음

C_n = [fib(n-1)] = W^(n-1)[fib(0)] = [W^(n-1)(0,1)]
      [fib(n)  ]          [fib(1)]   [W^(n-1)(1,1)]
W = [0 1]
    [1 1]

W의 거듭제곱은 O(lgn)번에 구할수 있음
```

#### 재귀적 동적 계획법의 장단점
1. 장점 : 좀더 직관적인 코드를 짤 수 있음
2. 장점 : 부분 문제 간의 의존 관계나 계산 순서에 대해 고민할 필요가 없음
3. 장점 : 전체 부분 문제 중 일부의 답만 필요할 경우 더 빠르게 동작함
4. 단점 : 슬라이딩 윈도 기법(필요한 부분의 일부만 메모이제이션)을 쓸 수 없음
5. 단점 : 스택 오버플로를 조심해야함

#### 반복적 동적 계획법의 장단점
1. 장점 : 구현이 대개 더 짧음
2. 장점 : 재귀 호출에 필요한 부하가 없기 때문에 조금 더 빠르게 동작함
3. 장점 : 슬라이딩 윈도 기법을 쓸 수 있음
4. 단점 : 구현이 좀 더 비직관적임
5. 단점 : 부분 문제 간의 의존 관계를 고려해 계산되는 순서를 고민해야함
#### 문제를 읽고 이해하기
https://codingcompetitions.withgoogle.com/codejam/round/000000000019fd74/00000000002b3034

input</br>
2
5
*CONUTS
*COCONUTS
*OCONUTS
*CONUTS
*S
2
*XZ
*XY

2
A*C*E
*B*D*


output</br>
Case #1: COCONUTS
Case #2: *

Case #1: COCONUTS
ABCDE
 
#### 재정의와 추상화<br>
-- 문제를 읽고 본인이 이해하기 쉬운 방식으로 해석<br>
패턴들을 모두 충족하는 문자열 출력 

#### 계획 세우기<br>


#### 계획 검증하기

위의 아이디어를 테스트 세트 3의 솔루션으로 일반화 할 수 있습니다. 테스트 세트 3의 각 패턴 p는 출력 단어의 접두사 (첫 번째 별표까지 p의 접두사)와 출력 단어의 접미사 (접미사)를 규정합니다. 마지막 별표 다음에 시작하는 p). 빈 접두사와 접미사를 허용하면 모든 패턴마다 정확히 하나를 얻습니다. 테스트 세트 2에서와 같은 방식으로 처리 할 수 ​​있으며 두 단계에서 불일치를 발견하지 않는 한 출력에 접두사 P와 접미사 S로 끝납니다.

그러나 별표가 두 개 이상인 패턴의 경우 중간 부분을 가질 수 있으므로 새로운 유형의 요구 사항이 적용됩니다. X가 첫 번째 별표까지 접두사이고, Y는 마지막 별표 뒤의 접미사이고, M1, M2, ..., Mk는 별표 사이의 문자열이며, 패턴의 별표 사이의 부분을 구문 분석한다고 가정합니다. 순서대로. X가 P의 접두사이고 Y가 S의 접미사임을 확인한 후, M1 * M2 * ... * Mk 패턴이 P와 S사이의 어딘가에 있어야 합니다.

M1M2 ... Mk, 즉 다른 별표가 제거 된 첫 번째 별표와 마지막 별표 사이에 나타나는 단어 (중간 단어)를 호출하겠습니다. 패턴의 중간 단어가 P와 S 외부의 출력 단어에서 발생하면 추가 요구 사항을 충족시킵니다. 그런 다음 P로 시작하여 모든 패턴의 중간 단어를 임의의 순서로 추가 한 다음 S를 추가하여 전체 유효한 출력을 빌드 할 수 있습니다. 중간 단어를 만들어 단일 별표 또는 연속된 별표만 있는 단어를 올바르게 처리해야합니다. 빈 문자열 각 중간 단어는 최대 98자를 포함하고 접두사와 접미사는 각각 최대 99자를 포함하므로 이러한 방식으로 작성된 출력은 최대 99 × 2 + 50 × 98 자이며 최대 10^4 자입니다.

---

모든 패턴에서 맨처음 *까지의 문자열들을 비교하여 가장 긴 문자열이 나머지 다른 문자열로 시작되는지 확인, 맨 마지막*부터 문자열 까지의 부분 문자열도 동일하게 계산<br>
중간의 문자열은 순서대로 넣음
